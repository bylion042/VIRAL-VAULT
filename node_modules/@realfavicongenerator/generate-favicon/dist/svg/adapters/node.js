"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNodeImageAdapter = void 0;
const svg_js_1 = require("@svgdotjs/svg.js");
const svgdom_1 = require("svgdom");
const sharp_1 = __importDefault(require("sharp"));
const dataUrlToBuffer = (dataUrl) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        const base64 = dataUrl.split(',')[1];
        const buffer = Buffer.from(base64, 'base64');
        resolve(buffer);
    });
});
const getNodeImageAdapter = () => {
    return {
        createSvg: () => {
            const window = (0, svgdom_1.createSVGWindow)();
            const document = window.document;
            (0, svg_js_1.registerWindow)(window, document);
            return (0, svg_js_1.SVG)(document.documentElement);
        },
        convertSvgToPng: (svg) => __awaiter(void 0, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const svgString = svg.svg();
                const svgBuffer = Buffer.from(svgString);
                (0, sharp_1.default)(svgBuffer)
                    .png()
                    .toBuffer((err, buffer, info) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(buffer);
                    }
                });
            });
        }),
        getImageSize: (dataUrl) => __awaiter(void 0, void 0, void 0, function* () {
            const buffer = yield dataUrlToBuffer(dataUrl);
            return new Promise((resolve, reject) => {
                (0, sharp_1.default)(buffer)
                    .metadata()
                    .then(metadata => {
                    const width = metadata.width;
                    const height = metadata.height;
                    if (width === undefined || height === undefined) {
                        reject('Failed to get image metadata');
                    }
                    else {
                        resolve({ width, height });
                    }
                })
                    .catch(err => {
                    reject(err);
                });
            });
        }),
        getImageData: (dataUrl, widthHeight) => __awaiter(void 0, void 0, void 0, function* () {
            const buffer = yield dataUrlToBuffer(dataUrl);
            return new Promise((resolve, reject) => {
                (0, sharp_1.default)(buffer)
                    .resize(widthHeight, widthHeight)
                    .raw()
                    .toBuffer((err, data, info) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        })
    };
};
exports.getNodeImageAdapter = getNodeImageAdapter;
